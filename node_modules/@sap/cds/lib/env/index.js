const { isfile, fs } = require('../utils')
const DEFAULTS = require('./defaults'), defaults = require.resolve ('./defaults')
const user_home = require('os').homedir()
const compat = require('./compat')
const path = require('path')


/**
 * Both a config inctance as well as factory for.
 */
class Config {

  /**
   * This is the one and only way to construct new instances.
   * Public API is through `cds.env.for (<context>)`
   * @param context - the app context, like 'cds' or 'your-app'
   * @returns {Config & typeof DEFAULTS}
   */
  for (context, cwd, _defaults=true) {
    if (!cwd) cwd = global.cds && global.cds.root || process.cwd()
    return new Config (context, cwd, _defaults)
  }


  /**
   * Only used internally, i.e. through cds.env.for(<context>)
   */
  constructor (_context, _home, _defaults=true) {
    Object.assign (this, { _context, _home, _sources:[] })
    this._profiles = _determineProfilesFrom (process.env)
    this._profiles._defined = new Set()

    // compat requires default values
    if (_context === 'cds' && _defaults)  this.add (DEFAULTS, defaults)
    if (_context === 'cds' && _defaults)  compat (this)
    if (!_home)  return

    // 1. fill-in defaults for process.env, unless already defined
    this._add_to_process_env (_home, 'default-env.json')
    // 1.5 additional env for dev
    if (process.env.NODE_ENV !== 'production') {
      this._add_to_process_env (_home, '.env')
    }

    // 2. read config sources in defined order
    if (_context === 'cds') {
      this._load (user_home, '.cdsrc.json')
      this._load (_home, '.cdsrc.json')
    }
    this._load (_home, 'package.json', p => p[_context])
    this.add (_process_env4(_context), '{process.env}')

    // 3. link dependant services (through kind/use)
    this._link_required_services()
    // 4. complete service configurations from VCAP
    this._add_vcap_services (process.env.VCAP_SERVICES)

    // 5. Add compatibility for mtx
    if (this.requires && this.requires.db) {
      if (this.requires.multitenancy !== undefined) {
        Object.defineProperty(this.requires.db, 'multiTenant', { value: !!this.requires.multitenancy })
      }
      else if (this.requires.db.multiTenant !== undefined) this.requires.multitenancy = this.requires.db.multiTenant
    }
  }

  /**
   * This is `this.requires` plus additional entries for all cds.required.<name>.service
   */
  get required_services_or_defs() {
    const dict = Object.create (this.requires)
    for (let [name,e] of Object.entries (this.requires)) if (e.service) {
      if (e.service in dict && e.service !== name) {
        console.error (`Datasource name '${e.service}' conflicts with 'service' definition referred to in 'cds.requires.${name}':`, e)
        throw new Error (`Datasource name '${e.service}' conflicts with service definition`)
      }
      else dict[e.service] = { ...e, name }
    }
    return super.required_services_or_defs = dict
  }

  set roots(v) { set (this, 'roots', v) }
  get roots() {
    return this.roots = Object.values(this.folders) .concat ([ 'schema', 'services' ])
  }

  get tmp() {
    return set (this, 'tmp', require('os').tmpdir())
  }

  /**
   * Retrieves the value for a config option, specified as a property path.
   */
  get (option) {
    if (!option)  return
    return option.split('.').reduce ((p,n)=> p && p[n], this)
  }

  /**
   * Provides access to system defaults for cds env.
   */
  get defaults() { return DEFAULTS }

  /**
   * Get effective options for .odata
   */
  get effective(){
    return super.effective = require('..').compiler._options.for.env()
  }

  /**
   * For BAS only: to find out whether this is a Java or Node.js project
   */
  get "project-nature" () {
    const has_pom_xml = [this.folders.srv,'.'] .some (
      f => isfile (path.join (this._home, f, 'pom.xml'))
    )
    return has_pom_xml ? 'java' : 'nodejs'
  }

  /**
   * For BAS only: get all defined profiles (could include some from the defaults)
   */
  get "defined-profiles" () {
    return Array.from (this._profiles._defined)
  }

  get profiles() {
    return super.profiles = Array.from (this._profiles)
  }


//////////////////////////////////////////////////////////////////////////
//
//    DANGER ZONE!
//    The following are internal APIs which can always change!
//


  _load (cwd, file, _conf=o=>o) {
    const json = _readJson (file = path.join(cwd, file))  // only support JSON
    if (json) this.add (_conf (json), file)
  }

  add (conf, /*from:*/ _src) {
    if (!conf)  return this
    if (_src)  this._sources.push (_src)
    _merge (this, conf, this._profiles)
    return this
  }

  _add_to_process_env (cwd, filename) {
    const file = path.resolve (cwd,filename)
    try {
      const all = require('../compile/etc/properties').read(file)
      for (const key in all) {
        if (key in process.env) continue // do not change existing env vars
        const val = all[key]
        process.env[key] = typeof val === 'string' ? val : JSON.stringify(val)
      }
      this._sources.push (file)
    } catch (e) {
      if (e instanceof SyntaxError)  console.error(`Error parsing '${file}': ${e.message}`)
      else if (e.code !== 'MODULE_NOT_FOUND')  console.error(e.message)
    }
  }

  _link_required_services () {
    const { requires } = this
    for (let each in requires)  requires[each] = _merged (each)
    function _merged (key) {
      const entry = requires[key]
      if (entry._is_merged || entry.kind === key || !(entry.kind in requires)) return entry
      const clone = _merge ({}, _merged (entry.kind))        // first apply inherited data
      _merge (clone, entry, false, false, o => _merge({},o)) // then apply overridden data
      return Object.defineProperty (clone, '_is_merged', {value:true})
    }
  }

  _add_vcap_services (VCAP_SERVICES) {
    if (this.features && this.features.vcaps === false)  return
    if (!this.requires)  return
    if (!VCAP_SERVICES) return
    try {
      const vcaps = JSON.parse (VCAP_SERVICES)
      const any = _add_vcap_services_to (this, vcaps)
      if (any)  this._sources.push ('{VCAP_SERVICES}')
    } catch(e) {
      throw new Error ('[cds.env] - failed to parse VCAP_SERVICES:\n  '+ e.message)
    }
  }


//////////////////////////////////////////////////////////////////////////
//
//    FORBIDDEN ZONE!
//    The following are hacks for tests which should not exist!
//    Tests should test public APIs, not internal ones.
//    Tests should even less intrude hacks to core components
//


  // FOR TESTS ONLY! --> PLEASE: tests should test public APIs (only)
  _for_tests (...conf) {
    const env = new Config('cds')
    this._for_tests.vcaps = (vcaps) => { _add_vcap_services_to (env, vcaps)}
    // merge all configs, then resolve profiles (same as in 'for' function above)
    for (let c of [...conf].reverse())  _merge(env, c, env._profiles)
    return env
  }
  // FOR TESTS ONLY! --> PLEASE: tests should test public APIs (only)
  _merge_with (src) {
    _merge (this, src, this._profiles)
    return this
  }
}




//////////////////////////////////////////////////////////////////////////
//
//    Local Helpers...
//

/**
 * @returns {Config} dst
 */
function _merge (dst, src, _profiles, _cloned) {
  const profiled = [], descr = Object.getOwnPropertyDescriptors(src)
  for (let p in descr) {
    const pd = descr[p]

    if ('get' in pd || !pd.enumerable) {
      Object.defineProperty(dst,p,pd)
      continue
    }

    if (_profiles && p[0] === '[') {
      if (_profiles._defined)  _profiles._defined.add (p.slice(1,-1))
      if (_profiles.has(p.slice(1,-1)))
        profiled.push (()=> _merge (dst, src[p], _profiles, _cloned))
      continue
    }

    const v = pd.value
    if (typeof v === 'object' && !Array.isArray(v)) {
      if (!dst[p]) dst[p] = {}; else if (_cloned)  dst[p] = _cloned(dst[p])
      _merge (dst[p], v, _profiles, _cloned)
      continue
    }

    if (v !== undefined) dst[p] = v
  }
  for (let each of profiled) each()
  return dst
}

function _process_env4 (prefix) {
  const {env} = process
  const PREF = prefix.toUpperCase(), my = { CONFIG: PREF+'_CONFIG', ENV: PREF+'_ENV' }
  const out = JSON.parse (env[my.CONFIG] || '{}')
  const pref_ = RegExp('^'+prefix+'[._]','i')
  for (let p in env) if (!(p in my) && pref_.test(p)) {
    const key = /[a-z]/.test(p) ? p : p.toLowerCase() //> CDS_FOO_BAR -> cds_foo_bar
    const path = key.slice(prefix.length+1) .split (key[prefix.length]) //> ['foo','bar']
    for (var o=out,next;;) {
      next = path.shift()
      if (!path.length) break
      o = o[next] || (o[next] = {})
    }
    o[next] = _value4(env[p])
  }
  return out
}

function _value4 (val) {
  if (val && val[0] === '{') try { return JSON.parse(val) } catch(e) {/* ignored */}
  if (val && val[0] === '[') try { return JSON.parse(val) } catch(e) {/* ignored */}
  if (val === 'true')  return true
  if (val === 'false')  return false
  if (!isNaN(val))  return parseFloat(val)
  return val
}


function _add_vcap_services_to (env, vcaps={}) {
  let any
  for (let service in env.requires) {
    const conf = env.requires [service]
    const { credentials } = (
      conf.vcap && _fetch (conf.vcap) ||  //> alternatives, e.g. { name:'foo', tag:'foo' }
      _fetch ({ name: service })  ||
      _fetch ({ tag: env._context+':'+service }) ||
      _fetch ({ tag: conf.dialect || conf.kind }) || // important for hanatrial, labeled 'hanatrial', tagged 'hana'
      _fetch ({ label: conf.dialect || conf.kind }) ||
      {/* not found */}
    )
    // Merge `credentials`.  Needed because some app-defined things like `credentials.destination` must survive.
    if (credentials)  any = conf.credentials = Object.assign ({}, conf.credentials, credentials)
  }
  return any

  function _fetch (predicate) {
    for (let k of Object.keys(predicate).reverse()) {
      const v = predicate[k]; if (!v) continue
      const filter = k === 'tag' ? e => _array(e,'tags').includes(v) : e => e[k] === v
      for (let stype in vcaps) {
        const found = _array(vcaps,stype) .find (filter)
        if (found)  return found
      }
    }
  }

  function _array(o,p) {
    const v = o[p]
    if (!v) return []
    if (Array.isArray(v)) return v
    throw new Error(`Expected VCAP entry '${p}' to be an array, but was: ${require('util').inspect(vcaps)}`)
  }

}

function _readJson (file) {
  try {
    const src = fs.readFileSync (require.resolve (file))
    return JSON.parse (src)
  } catch (e) {
    if (e instanceof SyntaxError)  console.error(`Error parsing '${file}': ${e.message}`)
    else if (e.code !== 'MODULE_NOT_FOUND')  console.error(e.message)
  }
}

function _determineProfilesFrom (env = process.env) {
  if (env.NODE_ENV !== 'production' && !/\bdevelopment\b/.test(env.CDS_ENV)) {
    if (env.CDS_ENV)  env.CDS_ENV += ',development'
    else  env.CDS_ENV = 'development'
  }
  const split = (x) => env[x] ? env[x].split (/\s*,\s*/) : []
  const profiles = [ ...split ('NODE_ENV'), ...split ('CDS_ENV') ]
  return new Set (profiles)
}


function set (o,p,value) {
  Object.defineProperty (o, p, {value,configurable:true,writable:true})
  return value
}


/** @type Config & typeof DEFAULTS */
module.exports = Config.prototype.for('cds')
/* eslint no-console:0 */
