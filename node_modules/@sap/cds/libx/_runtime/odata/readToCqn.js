const cds = require('../cds')
const { SELECT } = cds.ql

const getError = require('../common/error')
const { findCsnTargetFor } = require('../common/utils/csn')
const { getAllKeys } = require('../cds-services/adapter/odata-v4/odata-to-cqn/utils')
const rewriteAsterisk = require('../common/utils/rewriteAsterisk')
const { getMaxPageSize } = require('../common/utils/page')

const _hasAllEntityKeysInWhere = (keys, where) => {
  if (!(where && keys && keys.length)) return
  keys = keys.map(key => (Array.isArray(key) ? key.join('_') : key))
  for (const part of where) {
    if (part.ref && keys.indexOf(part.ref.join('_')) > -1) {
      keys.splice(keys.indexOf(part.ref.join('_')))
    }
  }

  return keys.length === 0
}

const _setLimits = (cqn, parsed, target) => {
  // adjust SELECT.limit based on @cds.query.limit annotations
  const rows = parsed.SELECT.limit.rows ? parsed.SELECT.limit.rows.val : Number.MAX_SAFE_INTEGER
  const offset = parsed.SELECT.limit.offset ? parsed.SELECT.limit.offset.val : 0
  cqn.limit(Math.min(rows, getMaxPageSize(target)), offset)
}

const _setRootInFrom = (cqn, target, model, namespace) => {
  const root = _findRoot(cqn, target, model, namespace)
  const from = cqn.SELECT.from
  if (from.ref[0].id) from.ref[0].id = root.name
  else from.ref[0] = root.name
  return cqn
}

const _findRoot = (cqn, target, model, namespace) => {
  const parsedTargetName = cqn.SELECT.from.ref[0].id || cqn.SELECT.from.ref[0]
  return target.name === parsedTargetName ? target : findCsnTargetFor(parsedTargetName, model, namespace)
}

const _resolveRef = (ref, model, parent) => {
  ref = ref.id || ref
  const element = parent && parent.elements && parent.elements[ref]
  let target = element || parent || model.definitions[ref]
  let aspect
  if (target && !target.elements) {
    if (target.target) {
      if (target.targetAspect) aspect = model.definitions[target.targetAspect]
      target = model.definitions[target.target]
    } else if (target.kind === 'type') {
      target = model.definitions[target.type]
    }
  }
  const keys = getAllKeys(aspect || target, false)
  return { target, keys, element }
}

const _resolveStructKeys = (where, keys) => {
  for (const el of where) {
    if (!el.ref) continue
    const keyIdx = keys.findIndex(key => Array.isArray(key) && key[key.length - 1] === el.ref[0])
    if (keyIdx > -1) {
      el.ref = [keys[keyIdx].join('_')]
      keys.splice(keyIdx, 1)
    }
  }
}

const _postProcess = (cqn, target, model, namespace) => {
  _setRootInFrom(cqn, target, model, namespace)
  let prev
  for (let i = 0; i < cqn.SELECT.from.ref.length; i++) {
    const ref = cqn.SELECT.from.ref[i]
    const { target, keys, element } = _resolveRef(ref, model, prev)
    if (ref.where) {
      // cases like `GET /Foo(1)/bar(2)` => `where` contains single `val`s
      if (ref.where.length === 1 && keys.length === 1) {
        ref.where = [{ ref: [Array.isArray(keys[0]) ? keys[0].join('_') : keys[0]] }, '=', ref.where[0]]
      } else {
        _resolveStructKeys(ref.where, keys)
      }
    }
    // $value never comes, $count is 2many, $ref is to be checked
    if (i === cqn.SELECT.from.ref.length - 1) {
      if (target && !target.elements) delete cqn.SELECT.columns
      if ((element && element.is2one) || (target && target._isSingleton) || _hasAllEntityKeysInWhere(keys, ref.where)) {
        cqn.SELECT.one = true
      }
    }
    prev = target
  }
  return cqn
}

/*
 * uses new odata2cqn
 */
const _newReadToCQN = ({ model, namespace }, target, req) => {
  let parsed

  try {
    parsed = cds.odata.parse.url(req.url || req._inRequestUrl)
  } catch (err) {
    throw getError(400, err.message)
  }

  _postProcess(parsed, target, model, namespace)

  const cqn = SELECT.from(parsed.SELECT.from, parsed.SELECT.columns)
  if (parsed.SELECT.search) cqn.SELECT.search = parsed.SELECT.search
  if (parsed.SELECT.where) cqn.SELECT.where = parsed.SELECT.where
  if (parsed.SELECT.orderBy) cqn.SELECT.orderBy = parsed.SELECT.orderBy
  if (parsed.SELECT.groupBy) cqn.SELECT.groupBy = parsed.SELECT.groupBy
  if (parsed.SELECT.count) cqn.SELECT.count = parsed.SELECT.count
  if (parsed.SELECT.one) {
    cqn.SELECT.one = parsed.SELECT.one
  } else if (parsed.SELECT.limit) {
    _setLimits(cqn, parsed, target, model)
  }
  if (!cds.env.features.rest_new_parser) {
    // REVISIT not needed for rest parser?
    rewriteAsterisk({ query: cqn, target })
  }

  return cqn
}

module.exports = { _newReadToCQN }
